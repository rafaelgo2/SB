DEPTH = 256;
WIDTH = 8;
ADDRESS_RADIX = HEX;
DATA_RADIX = BIN;
CONTENT
BEGIN

00        :  00001000;              -- loadi R0 IO ;
01        :  11111110;              -- 
02        :  00001001;              -- loadi R1 1 ;
03        :  00000001;              -- 
[04..05]:  00100000;              -- 
06        :  11010000;              -- jmpp R0 OP2 ;
07        :  00001100;              -- 
08        :  10001000;              -- call _OP1 ;
09        :  00100000;              -- 
0A        :  00111000;              -- jump _end ;
0B        :  00011100;              -- 
[0C..0D]:  00100000;              -- 
0E        :  11010000;              -- jmpp R0_OP3 ;
0F        :  10101010;              -- 
10        :  10001000;              -- call _OP2 ;
11        :  01000000;              -- 
12        :  00111000;              -- jump _end ;
13        :  00011100;              -- 
[14..15]:  00100000;              -- 
16        :  11010001;              -- jmpp R1_end ;
17        :  00011100;              -- 
18        :  10001000;              -- call _OP3 ;
19        :  10101010;              -- 
1A        :  00111000;              -- jump _end ;
1B        :  00011100;              -- 
[1C..1F]:  00000000;              -- 
20        :  00001000;              -- _OP1: loadi R0 IO ;   R0 representa a qntde de fatoriais a serem calculados
21        :  11111110;              -- 
22        :  01110001;              -- clear R1 ;    R1 representa a qntde de fatoriais ja calculados
23        :  00000000;              -- 
24        :  00001010;              -- _newOP1: loadi R2 IO ;  R2 eh o inteiro cujo fatorial sera calculado
25        :  11111110;              -- 
26        :  01001010;              -- jmpn R2_newOP1 ;   Se a entrada for negativa, a ignora
27        :  00100100;              -- 
28        :  01110011;              -- clear R3 ;
29        :  00000000;              -- 
2A        :  01101100;              -- loadc R4 8 ;
2B        :  00001000;              -- 
2C        :  10000011;              -- slt R3 R2 R4 ;   Verifica se a entrada eh maior ou igual a 8
2D        :  01010000;              -- 
2E        :  01000011;              -- jmpz R3_newOP1 ;   Se for, a ignora
2F        :  00100100;              -- 
30        :  00101011;              -- _loop: multiply R3 R2 ; Loop que multiplica resultado parcial (R3, inicialmente
31        :  01000000;              -- 
32        :  10111010;              -- addi R2-1 ;    igual a 1) pelo proximo fator
33        :  11111111;              -- 
34        :  11010010;              -- jmpp R2_loop ;   Enquanto o proximo fator for > 0, o fatorial ainda nao
35        :  00110000;              -- 
36        :  00010011;              -- storei R3 IO ;    esta pronto
37        :  11111110;              -- 
38        :  10111001;              -- addi R1 1 ;
39        :  00000001;              -- 
3A        :  11001010;              -- seq R2 R0 R1 ;
3B        :  00000100;              -- 
3C        :  01000010;              -- jmpz R2_newOP1 ;   Se R2 == 0, entao R0 != R1 e ainda ha fatoriais a serem
3D        :  00100100;              -- 
[3E..3F]:  00000000;              -- 
40        :  00001001;              -- _OP2: loadi R1 IO ;     R1 armazena A
41        :  11111110;              -- 
42        :  00001010;              -- loadi R2 IO ;     R2 armazena B
43        :  11111110;              -- 
44        :  00001011;              -- loadi R3 IO ;     R3 armazena C
45        :  11111110;              -- 
46        :  00001100;              -- loadi R4 IO ;     R4 armazena x
47        :  11111110;              -- 
48        :  01010101;              -- _newOP2: move R5 R4 ;    R5 calcula Ax^2
49        :  10000000;              -- 
4A        :  00101101;              -- multiply R5 R5 ;
4B        :  10100000;              -- 
4C        :  00101101;              -- multiply R5 R1 ;
4D        :  00100000;              -- 
4E        :  00101100;              -- multiply R4 R2 ;    R4 calcula Ax^2 + Bx + C
4F        :  01000000;              -- 
50        :  00011100;              -- add R4 R3 ;
51        :  01100000;              -- 
52        :  00011100;              -- add R4 R5 ;
53        :  10100000;              -- 
54        :  01111000;              -- moveSp -2 ;      Imprime e armazena o resultado da equacao
55        :  11111110;              -- 
56        :  10011100;              -- storeSp R4 0 ;
57        :  00000000;              -- 
58        :  00010100;              -- storei R4 IO ;
59        :  11111110;              -- 
5A        :  10111000;              -- addi R0 2 ;      R0 armazena o deslocamento do ponteiro da pilha
5B        :  00000010;              -- 
5C        :  00001100;              -- loadi R4 IO ;     Recebe o novo x e, caso seja nao nulo, reinicia
5D        :  11111110;              -- 
5E        :  11010100;              -- jmpp R4_newOP2 ;      o calculo
5F        :  01001000;              -- 
60        :  01001100;              -- jmpn R4_newOP2 ;
61        :  01001000;              -- 
62        :  00111000;              -- jump _order ;
63        :  01101110;              -- 
64        :  01010001;              -- _continueOrder: move R1 R0 ; Em passadas posteriores a primeira, retorna o
65        :  00000000;              -- 
66        :  10111001;              -- addi R1-2 ;      ponteiro da pilha para a posicao do momento
67        :  11111110;              -- 
68        :  01111000;              -- _continueOrderLoop: moveSp -2 ;  em que a ordenacao comeca
69        :  11111110;              -- 
6A        :  10111001;              -- addi R1-2 ;
6B        :  11111110;              -- 
6C        :  11010001;              -- jmpp R1_continueOrderLoop ; Enquanto sp nao estiver pronto, sp -= 2
6D        :  01101000;              -- 
6E        :  01010001;              -- _order: move R1 R0 ;   R1 indica a qntde de bytes da pilha percorridos
6F        :  00000000;              -- 
70        :  01101010;              -- loadc R2 1 ;     R2 indica se a pilha esta ordenada
71        :  00000001;              -- 
72        :  10010011;              -- _orderLoop: loadSp R3 0 ;  A pilha comeca a ser percorrida e ordenada, dois
73        :  00000000;              -- 
74        :  10010100;              -- loadSp R4 2 ;      valores seguidos sao carregados da pilha
75        :  00000010;              -- 
76        :  01110101;              -- clear R5 ;
77        :  00000000;              -- 
78        :  10000101;              -- slt R5 R4 R3 ;
79        :  10001100;              -- 
7A        :  01000101;              -- jmpz R5_nextStage ;   Se R5 = 0, os valores carregados estao em ordem
7B        :  10000010;              -- 
7C        :  01110010;              -- clear R2 ;      Caso contrario R2 eh alterado e os valores sao
7D        :  00000000;              -- 
7E        :  10011011;              -- storeSp R3 2 ;      ordenados na pilha
7F        :  00000010;              -- 
80        :  10011100;              -- storeSp R4 0 ;
81        :  00000000;              -- 
82        :  01111000;              -- _nextStage: moveSp 2 ;   Sp eh preparado para proxima leitura
83        :  00000010;              -- 
84        :  10111001;              -- addi R1-2 ;
85        :  11111110;              -- 
86        :  01101011;              -- loadc R3 3 ;
87        :  00000011;              -- 
88        :  01110100;              -- clear R4 ;
89        :  00000000;              -- 
8A        :  11000100;              -- sgt R4 R1 R3 ;     Verifica se R1 <= 2, pois o loop deve parar no
8B        :  00101100;              -- 
8C        :  11010100;              -- jmpp R4_orderLoop ;    no penultimo item da pilha
8D        :  01110010;              -- 
8E        :  01000010;              -- jmpz R2_continueOrder ;  Se a pilha foi totalmente percorrida e ainda
8F        :  01100100;              -- 
90        :  01010001;              -- move R1 R0 ;      assim nao estiver em ordem, o loop continua
91        :  00000000;              -- 
92        :  01010001;              -- _resetSP: move R1 R0 ;   Retorna o ponteiro da pilha para a posicao do
93        :  00000000;              -- 
94        :  10111001;              -- addi R1-2 ;      momento em que a ordenacao comeca
95        :  11111110;              -- 
96        :  01111000;              -- _continueResetSp: moveSp -2 ;
97        :  11111110;              -- 
98        :  10111001;              -- addi R1-2 ;
99        :  11111110;              -- 
9A        :  11010001;              -- jmpp R1_continueResetSp ;
9B        :  10010110;              -- 
9C        :  01010001;              -- move R1 R0 ;
9D        :  00000000;              -- 
9E        :  10010010;              -- _printSp: loadSp R2 0 ;   A pilha eh percorrida para impressao
9F        :  00000000;              -- 
A0        :  00010010;              -- storei R2 IO ;
A1        :  11111110;              -- 
A2        :  01111000;              -- moveSp 2 ;
A3        :  00000010;              -- 
A4        :  10111001;              -- addi R1-2 ;
A5        :  11111110;              -- 
A6        :  11010001;              -- jmpp R1_printSp ;
A7        :  10011110;              -- 
[A8..A9]:  00000000;              -- 
AA        :  01101110;              -- _OP3: loadc R6-1 ;
AB        :  11111111;              -- 
AC        :  01111000;              -- moveSp -2 ;
AD        :  11111110;              -- 
AE        :  10011110;              -- storeSp R6 0 ;                  Marcador de Fundo de Pilha
AF        :  00000000;              -- 
B0        :  10001000;              -- call _initR ;
B1        :  10110110;              -- 
B2        :  10001000;              -- call _initS ;
B3        :  11000110;              -- 
[B4..B5]:  00000000;              -- 
B6        :  00001000;              -- _initR: loadi R0 IO ;
B7        :  11111110;              -- 
B8        :  01010001;              -- move R1 R0 ;
B9        :  00000000;              -- 
BA        :  00100001;              -- subtract R1 R6 ;
BB        :  11000000;              -- 
BC        :  01000001;              -- jmpz R1_endR ;
BD        :  11000100;              -- 
BE        :  01111000;              -- moveSp -2 ;
BF        :  11111110;              -- 
C0        :  10011000;              -- storeSp R0 0 ;
C1        :  00000000;              -- 
C2        :  00111000;              -- jump _initR ;
C3        :  10110110;              -- 
C4        :  10100000;              -- _endR: ret  ;
C5        :  00000000;              -- 
C6        :  00001000;              -- _initS: loadi R0 IO ;
C7        :  11111110;              -- 
C8        :  10010011;              -- _while: loadSp R3 0 ;       Enquanto R3 diferente de -1
C9        :  00000000;              -- 
CA        :  01010100;              -- move R4 R3 ;
CB        :  01100000;              -- 
CC        :  00100100;              -- subtract R4 R6 ;
CD        :  11000000;              -- 
CE        :  01000100;              -- jmpz R4_endWhile ;
CF        :  11011010;              -- 
D0        :  01010100;              -- move R4 R3 ;
D1        :  01100000;              -- 
D2        :  00100100;              -- subtract R4 R0 ;
D3        :  00000000;              -- 
D4        :  01000100;              -- jmpz R4_endWhile ;     Se Topo da Pilha igual ao IO
D5        :  11011010;              -- 
D6        :  01111000;              -- moveSp 2 ;              Desce a pilha
D7        :  00000010;              -- 
D8        :  00111000;              -- jump _while ;
D9        :  11001000;              -- 
DA        :  00010011;              -- _endWhile: storei R3 IO ;   Escreva o valor encontrado
DB        :  11111110;              -- 
DC        :  10100000;              -- _endS: ret  ;
[DD..FF]:  00000000;              -- 
END;

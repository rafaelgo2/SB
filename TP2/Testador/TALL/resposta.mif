DEPTH = 256 ;
WIDTH = 8 ;
ADDRESS_RADIX = HEX ;
DATA_RADIX = BIN ;
CONTENT
BEGIN

00 : 00001000 ;    -- loadi R0 IO ; 0 1
01 : 11111110 ;    -- 
02 : 00001001 ;    -- loadi R1 1 ; 2 3
03 : 00000001 ;    -- 
[04..05] : 00100000 ;    -- 
06 : 11010000 ;    -- jmpp R0_this_OP2 ; 6 7
07 : 00001100 ;    -- 
08 : 10001000 ;    -- call _OP1 ; 8 9
09 : 00011100 ;    -- 
0A : 00111000 ;    -- jump _end ; 10 11
0B : 00011010 ;    -- 
[0C..0D] : 00100000 ;    -- 
0E : 11010000 ;    -- jmpp R0_this_OP3 ; 14 15
0F : 00010100 ;    -- 
10 : 10001000 ;    -- call _OP2 ; 16 17
11 : 00111100 ;    -- 
12 : 00111000 ;    -- jump _end ; 18 19
13 : 00011010 ;    -- 
[14..15] : 00100000 ;    -- 
16 : 11010001 ;    -- jmpp R1_end ; 22 23
17 : 00011010 ;    -- 
18 : 10001000 ;    -- call _OP3 ; 24 25
19 : 10100110 ;    -- 
[1A..1B] : 00000000 ;    -- 
1C : 00001000 ;    -- _OP1: loadi R0 IO ;  R0 representa a qntde de fatoriais a serem calculados
1D : 11111110 ;    -- 
1E : 01110001 ;    -- clear R1 ;  R1 representa a qntde de fatoriais ja calculados
1F : 00000000 ;    -- 
20 : 00001010 ;    -- _OP1new: loadi R2 IO ; R2 eh o inteiro cujo fatorial sera calculado
21 : 11111110 ;    -- 
22 : 01001010 ;    -- jmpn R2_OP1new ;  Se a entrada for negativa, a ignora
23 : 00100000 ;    -- 
24 : 01110011 ;    -- clear R3 ;
25 : 00000000 ;    -- 
26 : 01101100 ;    -- loadc R4 8 ;
27 : 00001000 ;    -- 
28 : 10000011 ;    -- slt R3 R2 R4 ;  Verifica se a entrada eh maior ou igual a 8
29 : 01010000 ;    -- 
2A : 01000011 ;    -- jmpz R3_OP1new ;  Se for, a ignora
2B : 00100000 ;    -- 
2C : 00101011 ;    -- _OP1loop: multiply R3 R2 ; Loop que multiplica resultado parcial (R3, inicialmente
2D : 01000000 ;    -- 
2E : 10111010 ;    -- addi R2-1 ;  igual a 1) pelo proximo fator
2F : 11111111 ;    -- 
30 : 11010010 ;    -- jmpp R2_OP1loop ;  Enquanto o proximo fator for > 0, o fatorial ainda nao
31 : 00101100 ;    -- 
32 : 00010011 ;    -- storei R3 IO ;  esta pronto
33 : 11111110 ;    -- 
34 : 10111001 ;    -- addi R1 1 ;
35 : 00000001 ;    -- 
36 : 11001010 ;    -- seq R2 R0 R1 ;
37 : 00000100 ;    -- 
38 : 01000010 ;    -- jmpz R2_OP1new ;  Se R2 == 0, entao R0 != R1 e ainda ha fatoriais a serem
39 : 00100000 ;    -- 
3A : 10100000 ;    -- ret  ;   calculados
3B : 00000000 ;    -- 
3C : 00001001 ;    -- _OP2: loadi R1 IO ;   R1 armazena A
3D : 11111110 ;    -- 
3E : 00001010 ;    -- loadi R2 IO ;   R2 armazena B
3F : 11111110 ;    -- 
40 : 00001011 ;    -- loadi R3 IO ;   R3 armazena C
41 : 11111110 ;    -- 
42 : 00001100 ;    -- loadi R4 IO ;   R4 armazena x
43 : 11111110 ;    -- 
44 : 01010101 ;    -- _OP2new: move R5 R4 ;  R5 calcula Ax^2
45 : 10000000 ;    -- 
46 : 00101101 ;    -- multiply R5 R5 ;
47 : 10100000 ;    -- 
48 : 00101101 ;    -- multiply R5 R1 ;
49 : 00100000 ;    -- 
4A : 00101100 ;    -- multiply R4 R2 ;  R4 calcula Ax^2 + Bx + C
4B : 01000000 ;    -- 
4C : 00011100 ;    -- add R4 R3 ;
4D : 01100000 ;    -- 
4E : 00011100 ;    -- add R4 R5 ;
4F : 10100000 ;    -- 
50 : 01111000 ;    -- moveSp -2 ;   Imprime e armazena o resultado da equacao
51 : 11111110 ;    -- 
52 : 10011100 ;    -- storeSp R4 0 ;
53 : 00000000 ;    -- 
54 : 00010100 ;    -- storei R4 IO ;
55 : 11111110 ;    -- 
56 : 10111000 ;    -- addi R0 2 ;   R0 armazena o deslocamento do ponteiro da pilha
57 : 00000010 ;    -- 
58 : 00001100 ;    -- loadi R4 IO ;   Recebe o novo x e, caso seja nao nulo, reinicia
59 : 11111110 ;    -- 
5A : 11010100 ;    -- jmpp R4_OP2new ;   o calculo
5B : 01000100 ;    -- 
5C : 01001100 ;    -- jmpn R4_OP2new ;
5D : 01000100 ;    -- 
5E : 00111000 ;    -- jump _OP2order ;
5F : 01101010 ;    -- 
60 : 01010001 ;    -- _OP2continueOrder: move R1 R0 ; Em passadas posteriores a primeira, retorna o
61 : 00000000 ;    -- 
62 : 10111001 ;    -- addi R1-2 ;   ponteiro da pilha para a posicao do momento
63 : 11111110 ;    -- 
64 : 01111000 ;    -- _OP2continueOrderLoop: moveSp -2 ; em que a ordenacao comeca
65 : 11111110 ;    -- 
66 : 10111001 ;    -- addi R1-2 ;
67 : 11111110 ;    -- 
68 : 11010001 ;    -- jmpp R1_OP2continueOrderLoop ; Enquanto sp nao estiver pronto, sp -= 2
69 : 01100100 ;    -- 
6A : 01010001 ;    -- _OP2order: move R1 R0 ;  R1 indica a qntde de bytes da pilha percorridos
6B : 00000000 ;    -- 
6C : 01101010 ;    -- loadc R2 1 ;   R2 indica se a pilha esta ordenada
6D : 00000001 ;    -- 
6E : 10010011 ;    -- _OP2orderLoop: loadSp R3 0 ; A pilha comeca a ser percorrida e ordenada, dois
6F : 00000000 ;    -- 
70 : 10010100 ;    -- loadSp R4 2 ;   valores seguidos sao carregados da pilha
71 : 00000010 ;    -- 
72 : 01110101 ;    -- clear R5 ;
73 : 00000000 ;    -- 
74 : 10000101 ;    -- slt R5 R4 R3 ;
75 : 10001100 ;    -- 
76 : 01000101 ;    -- jmpz R5_OP2nextStage ;  Se R5 = 0, os valores carregados estao em ordem
77 : 01111110 ;    -- 
78 : 01110010 ;    -- clear R2 ;   Caso contrario R2 eh alterado e os valores sao
79 : 00000000 ;    -- 
7A : 10011011 ;    -- storeSp R3 2 ;   ordenados na pilha
7B : 00000010 ;    -- 
7C : 10011100 ;    -- storeSp R4 0 ;
7D : 00000000 ;    -- 
7E : 01111000 ;    -- _OP2nextStage: moveSp 2 ;  Sp eh preparado para proxima leitura
7F : 00000010 ;    -- 
80 : 10111001 ;    -- addi R1-2 ;
81 : 11111110 ;    -- 
82 : 01101011 ;    -- loadc R3 3 ;
83 : 00000011 ;    -- 
84 : 01110100 ;    -- clear R4 ;
85 : 00000000 ;    -- 
86 : 11000100 ;    -- sgt R4 R1 R3 ;   Verifica se R1 <= 2, pois o loop deve parar no
87 : 00101100 ;    -- 
88 : 11010100 ;    -- jmpp R4_OP2orderLoop ;  no penultimo item da pilha
89 : 01101110 ;    -- 
8A : 01000010 ;    -- jmpz R2_OP2continueOrder ; Se a pilha foi totalmente percorrida e ainda
8B : 01100000 ;    -- 
8C : 01010001 ;    -- move R1 R0 ;   assim nao estiver em ordem, o loop continua
8D : 00000000 ;    -- 
8E : 01010001 ;    -- _OP2resetSP: move R1 R0 ;  Retorna o ponteiro da pilha para a posicao do
8F : 00000000 ;    -- 
90 : 10111001 ;    -- addi R1-2 ;   momento em que a ordenacao comeca
91 : 11111110 ;    -- 
92 : 01111000 ;    -- _OP2continueResetSp: moveSp -2 ;
93 : 11111110 ;    -- 
94 : 10111001 ;    -- addi R1-2 ;
95 : 11111110 ;    -- 
96 : 11010001 ;    -- jmpp R1_OP2continueResetSp ;
97 : 10010010 ;    -- 
98 : 01010001 ;    -- move R1 R0 ;
99 : 00000000 ;    -- 
9A : 10010010 ;    -- _OP2printSp: loadSp R2 0 ;  A pilha eh percorrida para impressao
9B : 00000000 ;    -- 
9C : 00010010 ;    -- storei R2 IO ;
9D : 11111110 ;    -- 
9E : 01111000 ;    -- moveSp 2 ;
9F : 00000010 ;    -- 
A0 : 10111001 ;    -- addi R1-2 ;
A1 : 11111110 ;    -- 
A2 : 11010001 ;    -- jmpp R1_OP2printSp ;
A3 : 10011010 ;    -- 
A4 : 10100000 ;    -- ret  ;
A5 : 00000000 ;    -- 
A6 : 00001010 ;    -- _OP3: loadi R2 IO ;
A7 : 11111110 ;    -- 
A8 : 00001110 ;    -- loadi R6 one ;
A9 : 11000100 ;    -- 
AA : 00001000 ;    -- loadi R0 zero ;
AB : 11000010 ;    -- 
AC : 00001001 ;    -- loadi R1 one ;
AD : 11000100 ;    -- 
AE : 00001011 ;    -- loadi R3 zero ;
AF : 11000010 ;    -- 
B0 : 01000010 ;    -- _OP3loop: jmpz R2_OP3endLoop ;
B1 : 10111100 ;    -- 
B2 : 01010011 ;    -- move R3 R1 ;
B3 : 00100000 ;    -- 
B4 : 00011001 ;    -- add R1 R0 ;
B5 : 00000000 ;    -- 
B6 : 01010000 ;    -- move R0 R3 ;
B7 : 01100000 ;    -- 
B8 : 00100010 ;    -- subtract R2 R6 ;
B9 : 11000000 ;    -- 
BA : 00111000 ;    -- jump _OP3loop ;
BB : 10110000 ;    -- 
BC : 00010000 ;    -- _OP3endLoop: storei R0 IO ;
BD : 11111110 ;    -- 
BE : 10100000 ;    -- ret  ;
[BF..C4] : 00000000 ;    -- one: .data 2 1 ;
C5 : 00000001 ;    -- 
[C6..FF] : 00000000 ;    -- 
END ;
